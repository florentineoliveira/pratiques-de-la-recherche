<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>L’estimateur des Moindres Carrés Ordinaires (OLS)</title>
    <meta charset="utf-8" />
    <meta name="author" content="Florentine Oliveira" />
    <meta name="date" content="2024-09-18" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# L’estimateur des Moindres Carrés Ordinaires (OLS)
]
.subtitle[
## Pratiques de la Recherche en Économie
]
.author[
### Florentine Oliveira
]
.date[
### 2024-09-18
]

---







layout: true

---
# Cette séance

&amp;nbsp;

1. L'estimateur des MCO    
  1.1. Modèle linéaire univarié et interprétation géométrique    
  1.3. Du modèle univarié au modèle multivarié    
  
2. Hypothèses de l'estimateur des MCO   
  2.1. Linéarité   
  2.2.      
  
3. Propriétés statistiques   
  3.1. Espérance   
  3.2. Variance     
  
4. Remise en cause des hypothèses       


---
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique   

La régression linéaire simple est une méthode statistique permettant de trouver une relation **linéaire** entre

  * une **variable expliquée** (ou **variable dépendante** ou ***outcome***), *** `\(y\)` ***
  
  * une **variable explicative** (ou **variable indépendante** ou **régresseur**), *** `\(x\)` ***
  
  
La relation linéaire entre `\(y\)` et `\(x\)` n'est pas parfaite: elle est perturbée par une **erreur** (ou **bruit** ou ***noise***), `\(\varepsilon\)`.

Pour chaque individu `\(i\)`, on observe à la fois `\(x_i\)` et `\(y_i\)` ce qui nous permet de représenter la *distribution jointe* de ces deux variables.

Le modèle linéaire univarié s'écrit, `\(\forall \; i\)`, 

`$$y_i = \alpha + \beta x_i + \varepsilon_i$$`


---
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

On considère l'échantillon suivant

--

&lt;img src="lecture_3_fr_files/figure-html/nuage-1.svg" style="display: block; margin: auto;" /&gt;


---
count: false
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

Pour toute droite `\(\tilde{y} = \tilde{\alpha} + \tilde{\beta} x\)`,

&lt;img src="lecture_3_fr_files/figure-html/nuage et droite-1.svg" style="display: block; margin: auto;" /&gt;



---
count: false
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

Pour toute droite `\(\tilde{y} = \tilde{\alpha} + \tilde{\beta} x\)`, on peut calculer les erreurs: `\(e_i = y_i - \tilde{y}_i\)`

&lt;img src="lecture_3_fr_files/figure-html/nuage et droite et point y2-1.svg" style="display: block; margin: auto;" /&gt;


---
count: false
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

Pour toute droite `\(\tilde{y} = \tilde{\alpha} + \tilde{\beta} x\)`, on peut calculer les erreurs: `\(e_i = y_i - \tilde{y}_i\)`

&lt;img src="lecture_3_fr_files/figure-html/nuage et droite et point y2 et e2-1.svg" style="display: block; margin: auto;" /&gt;


---
count: false
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

Pour toute droite `\(\tilde{y} = \tilde{\alpha} + \tilde{\beta} x\)`, on peut calculer les erreurs: `\(e_i = y_i - \tilde{y}_i\)`

&lt;img src="lecture_3_fr_files/figure-html/nuage et droite et toutes erreurs-1.svg" style="display: block; margin: auto;" /&gt;


---
count: false
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

Pour toute droite `\(\tilde{y} = \tilde{\alpha} + \tilde{\beta} x\)`, on peut calculer les erreurs: `\(e_i = y_i - \tilde{y}_i\)`

&lt;img src="lecture_3_fr_files/figure-html/nuage et autre droite et toutes erreurs -1.svg" style="display: block; margin: auto;" /&gt;



---
count: false
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

SCE = `\(\left(\sum \varepsilon_i^2\right)\)`: les erreurs importantes ont de plus grosses pénalités.

&lt;img src="lecture_3_fr_files/figure-html/penalties-1.svg" style="display: block; margin: auto;" /&gt;


---
count: false
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

L'estimateur des MCO (*OLS*) calcule `\(\hat{\alpha}\)` et `\(\hat{\beta}\)` qui **&lt;span style="color:#dd0747;"&gt;minimisent la SCE&lt;/span&gt;**.

&lt;img src="lecture_3_fr_files/figure-html/mco penalties-1.svg" style="display: block; margin: auto;" /&gt;

---
count: false
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

L'estimateur des MCO (*OLS*) calcule `\(\hat{\alpha}\)` et `\(\hat{\beta}\)` qui **&lt;span style="color:#dd0747;"&gt;minimisent la SCE&lt;/span&gt;**.

&lt;img src="lecture_3_fr_files/figure-html/mco-1.svg" style="display: block; margin: auto;" /&gt;

---
name: OLS
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

### Formellement

L'estimateur des MCO calcule `\(\hat{\alpha}\)` et `\(\hat{\beta}\)` qui minimmise la Somme des Carrés des Erreurs (SCE, ou Sum of Squared Errors en anglais) : 

`$$\min_{\hat{\alpha},\, \hat{\beta}} \text{SCE} =\sum_{i=1}^N \varepsilon _i^2$$`
On obtient, dans le cas univarié:

.center[
`\(\hat{\alpha} = \overline{y} - \hat{\beta} \overline{x}\)` 

`\(\hat{\beta} = \dfrac{Cov(x,y)}{Var(x)}\)`
]

[Maths](#derivation)

---
# 1. L'estimateur des MCO   

## 1.1. Modèle linéaire univarié et interprétation géométrique  

### Implémentation sur `R`

- Calcul de la variance empirique


``` r
var(x)
```

- Calcul de la covariance empirique

``` r
cov(x,y)
```

- Régression linéaire (simple)

``` r
lm(variable dépendante ~  variable indépendante, data = data.frame)
```

- Résultats de l'estimation visibles avec la commande `summary`

---
# 2. Estimateur des Moindres Carrés Ordinaires

## `\(\hat{\beta}\)` est une variable aléatoire
.pull-left[
&lt;img src="lecture_3_fr_files/figure-html/scatter1-1.svg" style="display: block; margin: auto;" /&gt;
]

--

.pull-left[
&lt;img src="lecture_3_fr_files/figure-html/sample1 scatter-1.svg" style="display: block; margin: auto;" /&gt;
]


---
# 2. Estimateur des Moindres Carrés Ordinaires

## `\(\hat{\beta}\)` est une variable aléatoire
.pull-left[

&lt;img src="lecture_3_fr_files/figure-html/scatter1 opur sample 2-1.svg" style="display: block; margin: auto;" /&gt;


]


.pull-left[

&lt;img src="lecture_3_fr_files/figure-html/sample2 scatter-1.svg" style="display: block; margin: auto;" /&gt;
]



---
# 2. Estimateur des Moindres Carrés Ordinaires

## `\(\hat{\beta}\)` est une variable aléatoire
.pull-left[

&lt;img src="lecture_3_fr_files/figure-html/scatter1 opur sample 3-1.svg" style="display: block; margin: auto;" /&gt;
]


.pull-left[

&lt;img src="lecture_3_fr_files/figure-html/sample3 scatter-1.svg" style="display: block; margin: auto;" /&gt;
]

---
# 2. Estimateur des Moindres Carrés Ordinaires

## `\(\hat{\beta}\)` est une variable aléatoire

.pull-left[
&lt;img src="lecture_3_fr_files/figure-html/simulation-1.png" style="display: block; margin: auto;" /&gt;
]

--

.pull-right[

- En **moyenne**, les droites de régressions sur les échantillons sont très proches de la droite de régression sur l'ensemble de la population


- Mais certaines en sont très éloignées


- ** `\(\hat{\beta}\)` est une variable aléatoire : sa valeur est propre à l'échantillon sur lequel il est estimé**


- `\(\implies\)` Tout l'enjeu pour l'économètre est d'assurer que l'échantillon est aléatoire et/ou représentatif de telle sorte à ce que `\(\hat{\beta} \rightarrow \beta\)`

]

---
### Échantillon non représentatif

.pull-left[
&lt;img src="lecture_3_fr_files/figure-html/selected sample-1.png" style="display: block; margin: auto;" /&gt;
]


---
background-color: #f19bb5
# Application 

### Taille de la fratrie et performances scolaires

<div class="countdown" id="timer_ccea92ac" data-update-every="1" tabindex="0" style="top:0;right:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">07</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

**Intuition** 

1: Selon vous, quelle est la relation entre **taille de la fratrie** et **performances scolaires** ?


**Sur `R`: se familiariser avec les données**

 
2: Importer la [base de données]() `simulated_data_black_et_al_2005.csv` que vous nommerez `data`

3: Calculer quelques statistiques descriptives de la **taille de la fratrie** (`family_size`) et du **nombre d'années d'études** (`education`): 
  - moyenne
  - écart-type
  - corrélation entre les deux variables

4: Représenter le nuage de points qui définit la relation entre **taille de la fratrie** et **nombre d'années d'études**


---
background-color: #fbe6ec
# Solution

### Intuition 

Selon vous, quelle est la relation entre **taille de la fratrie** et **performances scolaires** ?

--

- Relation théorique ([Becker (1960)](https://www.nber.org/system/files/chapters/c2387/c2387.pdf), [Becker and Lewis (1973)](https://www.jstor.org/stable/1840425), [Becker and Tomes (1976)](https://www.jstor.org/stable/1831106)): 

  - arbitrage entre la quantité et la *qualité* des enfants au sein d'une famille.

--

- Relations empiriques ([Black, Devereux and Salvanes (2005)](https://watermark.silverchair.com/120-2-669.pdf?token=AQECAHi208BE49Ooan9kkhW_Ercy7Dm3ZL_9Cf3qfKAc485ysgAAA2YwggNiBgkqhkiG9w0BBwagggNTMIIDTwIBADCCA0gGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQMRUFpt9yUxU8Wuu4FAgEQgIIDGVcdvdpNZkmD_Fbj4_wa9HaGQTAoM2tQsF2wuRUmWvvlH23Fhxp68TwZUK_P2MpI1e4pA0PyMp-QAURQMsN_P7FcQuEoYqMkBs_7l-8reeiCLHbQYIdRAyJ7Ud-hDxSJwuZ1iqH-7kMcMtNHtrlh5JydP2Ya8p9GRWtFVmtfq4bzIbKfbqh2dI4_dv_8mVc-h8CQQxE-J7ME9RH9pw-1ZQccud0e4RCqHuVa6tR3ByEceFgsmwl1l779gZjQGoBrLm5sBLxc47Ni6bVW8_Czit3EPJjaq6vh22L8XnfsF256FHmtDgmSFUTljZ8l37VwGA4Y_4q62_k4RKJZbJft3i7_XW2eJxcfWAFTje1jjUIHi81WitYT24sisKkRmqHak6_yQFwbayocifHA23T8PfXoKqkLlDO9ewUYL83HrGsOrPHSd8JbitwP400KOWotEZVDATVqQxJhnJRa6LsVTtiYuZVcC6-PLcVSTAHPDbRF7Q_WcB4QL-0MeEorgQ-ULn_9trRFCjrs3tXlCo_6qPEvDFtAm3YAcZVVEaCcMRcwY5cnLeIL7q2gsB06txdyzGgriCrc_gMZksCy3M_V32yX8pP4RE81BP6cggKZu7BwlLzh3nOozg0AJqvC00IKcJ7k5iMhjSARFURevVtIhWz3RQ6_CAQAU5M4PfSaAnYzDHLO2FDKfnTThgJmZEYMAqUUJOXgLn4jrcE4OLXxuPLHfxdiqoAiAfhzTsTu6Wvn5x0YTaRq27_2bhw2pMXRNDotTjHQW6StxWxhlCvynLBVONRE4YKiXLN_YCXTd0FNjEyGQQRjmLbTQK6vvGgReEP2aUdB4-FarpRYU0b3DMFn6eFCUx0hdFMc2BunByvGDB8f3h5aubWaEZM4E-H-a7fIA_FE9wAORKqHd7wM1rx2x3nYVGk9k0HqHbYCyO48lAS2L5DmKUXPhH81ugVBbWCgX9EpzyLgUlloaTWnseadBr1rZBsUOUBqZ0M9gzJjtzYbqH8xvJiFtZ4Za01xveOJAv4qBp3uib9MHFtJqK1JkpQRP214aEQ)): 
  - données norvégiennes exhaustives
  - corrélation négative entre la taille des fratries et le nombre d'années de scolarisation moyenne des enfants

---
background-color: #fbe6ec
# Solution

### Sur `R`: se familiariser avec les données


Importer la [base de données]() `simulated_data_black_et_al_2005.csv` que vous nommerez `data`



``` r
# Import data
data = read.csv2(here("Lecture 3/data", "simulated_data_black_et_al_2005.csv"), sep = ",") %&gt;% 
  mutate(family_size = as.numeric(family_size),
         education = as.numeric(education),
         age_2000 = as.numeric(age_2000))
# data = read_sav(here("Lecture 3/data", "asciiqob.sav"))
```
 
---
background-color: #fbe6ec
# Solution


Calculer quelques statistiques descriptives de la **taille de la fratrie** (`family_size`) et du **nombre d'années d'études** (`education`): 
  - moyenne
  - écart-type
  - corrélation entre les deux variables


``` r
data %&gt;%
  summarise(
    across(c(family_size, education), ~ round(mean(.), 2), .names = "mean_{.col}"),
    across(c(family_size, education), ~ round(sd(.), 2), .names = "sd_{.col}"),
    correlation = cor(family_size, education, use = "complete.obs")
  )
```

```
##   mean_family_size mean_education sd_family_size sd_education correlation
## 1             2.92          12.15           1.18          2.4 -0.05414467
```


---
background-color: #fbe6ec

# Solution 

Représenter le nuage de points qui définit la relation entre **taille de la fratrie** et **nombre d'années d'études**

&lt;img src="lecture_3_fr_files/figure-html/unnamed-chunk-6-1.svg" style="display: block; margin: auto;" /&gt;










---
## Taille de fratrie et nombre d'années d'études

.middle[
&lt;img src="lecture_3_fr_files/figure-html/unnamed-chunk-9-1.svg" style="display: block; margin: auto;" /&gt;
]

---

## Taille de fratrie et nombre d'années d'études

.middle[
&lt;img src="lecture_3_fr_files/figure-html/unnamed-chunk-10-1.svg" style="display: block; margin: auto;" /&gt;
]


---
# 1. L'estimateur des MCO   

## 1.2. Du modèle univarié au modèle multivarié




$$\hat{\beta} = (X'X)^{-1}X'Y $$






---
## 5. Hypothèses de l'estimateur des MCO

- `\(H_1\)` **Linéarité**: le modèle est linéaire dans les paramètres. 
  - Formellement, `\(\frac{\partial y_i}{\partial x_{ik}} = \beta_k\)` `\(\forall k =1, ...; K\)`

--

- `\(H_2\)` **X est exogène**: formellement, `\(\mathbb{E}(\varepsilon|X) = 0\)` 

--

- `\(H_3\)` : Il y a suffisamment de variation dans X. 
  - Dit autrement, chaque variable explicative apporte une information qui lui est propre
  - Formellement, s'il y a plusieurs variables explicatives, elles ne sont pas colinéaires, donc `\((X'X)\)` est inversible. 

--

- `\(H_4\)` : **Homoscédasticité** : `\(\varepsilon_i\)` est _iid_ et de distribution `\(\mathcal{N}(0, \sigma^2)\)` 



---
## Remise en cause de `\(H_1\)`

**Quartet d'Anscombe**


&lt;img src="lecture_3_fr_files/figure-html/unnamed-chunk-11-1.svg" style="display: block; margin: auto;" /&gt;





---
## Remise en cause de `\(H_1\)`

**Quartet d'Anscombe**





---
## Relation non-linéaire




---
## Outliers

&lt;img src="lecture_3_fr_files/figure-html/unnamed-chunk-14-1.svg" style="display: block; margin: auto;" /&gt;


---
### Identifier les outliers

.pull-left[
&lt;img src="lecture_3_fr_files/figure-html/outlier-1.png" style="display: block; margin: auto;" /&gt;
]

--

.pull-right[

**Identifier les outliers**:

- à partir de l'**écart-type**: *lorsque la distribution des données est relativement symmetrique*. Une observation éloignée de plus de 3 écarts-types de la moyenne peut être considérée comme une valeur abberrante 

- à partir de l'**écart interquartile**: peut être considérée comme outlier toute observation non incluse dans l'intervalle `\([Q_1 - k(Q_3 - Q_1) \;;\; Q3 + k (Q3 - Q1)]\)`  où `\(k&gt;0\)`. On détecte des outliers *moyens* pour `\(k=1.5\)`, et *extrêmes* pour `\(k=3\)`
]

---
## Remise en cause de `\(H_2\)`


---
## Remise en cause de `\(H_3\)`


---
## Remise en cause de `\(H_4\)`

---
# Références

- [Florian Oswald](https://raw.githack.com/ScPoEcon/ScPoEconometrics-Slides/master/chapter_slr/chapter_slr.html)
- [Edward Rubin](https://github.com/edrubin/EC421S19/tree/master)
- [Scott Cunningham](https://mixtape.scunning.com)
- [Scientific Research and Methodology, Peter K. Dunn](https://bookdown.org/pkaldunn/Book/)
- 

---
class: center, middle

# Annexe


---
name: derivation

## Calcul de l'estimateur des MCO dans le cas univarié

On a : `\(\text{SCE} = \sum_{i = 1}^N \varepsilon_i^2 = \sum_{i = 1}^N \left( y_i - \hat{y}_i\right)^2  = \sum_{i = 1}^N \left( y_i^2 - 2 y_i \hat{\alpha} - 2 y_i \hat{\beta} x_i + \hat{\alpha}^2 + 2 \hat{\alpha} \hat{\beta} x_i + \hat{\beta}^2 x_i^2 \right)\)`

Les conditions de premier ordre de la minimisation sont:

.center[
`\(\dfrac{\partial \text{SSE}}{\partial \hat{\alpha}} = 0\)`   **(1)**      et      `\(\dfrac{\partial \text{SSE}}{\partial \hat{\beta}} = 0\)`    **(2)**
]

Pour (1):

`$$\begin{align} \dfrac{\partial \text{SSE}}{\partial \hat{\alpha}} = 0 
 \;\;\;\; &amp;\implies \sum_{i = 1}^N \left( 2 \hat{\alpha} + 2 \hat{\beta} x_i - 2 y_i \right) = 2n \hat{\alpha} + 2 \hat{\beta} \sum_{i = 1}^N x_i - 2 \sum_{i = 1}^N y_i = 2n \hat{\alpha}2n \hat{\beta} \overline{x} - 2n \overline{y} = \; 0 \\&amp;\implies \color{#dd0747}{\hat{\alpha} = \overline{y} - \hat{\beta} \overline{x}} \;\;\;\;\;(3)\end{align}$$`
 
où 
`\(\overline{x} = \frac{\sum_{i=1}^N x_i}{n}\)` et `\(\overline{y} = \frac{\sum_{i=1}^N y_i}{n}\)` sont les moyennes de `\(x\)` et `\(y\)` sur notre échantillon de taille `\(n\)`.


---

Pour (2):

`$$\begin{align} 
\dfrac{\partial \text{SSE}}{\partial \hat{\beta}} = 0  \;\;\;\; &amp;\implies \sum_{i = 1}^N \left( 2 \hat{\alpha} x_i + 2 \hat{\beta} x_i^2 - 2 y_i x_i \right) = 2n \hat{\alpha} \overline{x} + 2 \hat{\beta} \sum_{i = 1}^N x_i^2 - 2 \sum_{i = 1}^N y_i x_i = 0   \;\;\;\;\; (4)\end{align}$$`


En remplaçant `\(\hat{\alpha}\)` par sa valeur définie dans (3), on obtient:
.center[
`\(2n \left(\overline{y} - \hat{\beta} \overline{x}\right) \overline{x} + 2 \hat{\beta} \sum_{i = 1}^N  x_i^2 - 2 \sum_{i = 1}^N  y_i x_i = 0\)`
]

en développant, 
.center[
`$$2n \overline{y} \, \overline{x} - 2n \hat{\beta} \overline{x}^2 + 2 \hat{\beta} \sum_{i = 1}^N  x_i^2 - 2 \sum_{i = 1}^N  y_i x_i = 0 \; \implies \; 2 \hat{\beta} \left( \sum_{i = 1}^N  x_i^2 - n \overline{x}^2 \right) = 2 \sum_{i = 1}^N  y_i x_i - 2n \overline{y}\,\overline{x}$$`

`$$\implies \color{#dd0747}{\hat{\beta}} = \dfrac{\sum_{i = 1}^N  y_i x_i - 2n \overline{y}\,\overline{x}}{\sum_{i = 1}^N  x_i^2 - n \overline{x}^2} = \dfrac{\sum_{i = 1}^N  (x_i - \overline{x})(y_i - \overline{y})}{\sum_{i = 1}^N  (x_i - \overline{x})^2}   \color{#dd0747}{=\dfrac{Cov(x,y)}{Var(x)}}$$`
]

[Back](#OLS)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
