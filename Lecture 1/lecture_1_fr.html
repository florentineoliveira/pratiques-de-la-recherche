<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Refresher</title>
    <meta charset="utf-8" />
    <meta name="author" content="Florentine Oliveira" />
    <meta name="date" content="2024-11-09" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/countdown/countdown.css" rel="stylesheet" />
    <script src="libs/countdown/countdown.js"></script>
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# <code>R</code>efresher
]
.subtitle[
## Pratiques de la Recherche en √âconomie
]
.author[
### Florentine Oliveira
]
.date[
### 2024-11-09
]

---




layout: true


---

&lt;link rel="shortcut icon" href="#" /&gt;

# About me

&amp;nbsp;


Doctorante en √âconomie √† PSE en 3√®me ann√©e

Champs de recherche: √©conomie de la famille, de l'√©ducation, du travail


&amp;nbsp;

&amp;nbsp;

.center[
**Pour me contacter, si vous avez des questions ou envie/besoin de parler**:

florentine.oliveira@psemail.eu   

Campus Jourdan, Bureau R4-54 
]

---
# Objectifs du cours

&amp;nbsp;

&amp;nbsp;

- Se familiariser avec 
  - les techniques **√©conom√©triques** de base
  - la **recherche** en **√©conomie empirique**

- Apprendre le language de programmation `R`

&amp;nbsp;

`\(\implies\)` pour pouvoir r√©aliser votre **m√©moire** !



---
# Roadmap


&amp;nbsp;


### Semestre 1

1. S√©ance 1 (aujourd'hui): Rappels de `R` 
2. S√©ance 2 (12/11/2024): `\(\LaTeX\)` et R Markdown
3. S√©ance 3 (19/12/2024): R√©gressions Lin√©aires et Causalit√©

### Semestre 2
4. S√©ance 4 (04/02/2025): Variables de Contr√¥le et Matching
5. S√©ance 5 (18/02/2025): M√©thode des Variables Instrumentales
6. S√©ance 6 (11/03/2025): M√©thode des Doubles-Diff√©rences (DiD)
7. S√©ance 7 (25/03/2025): Regression Discontinuity Design (RDD)
8. S√©ance 8 (08/04/2025): Q &amp; A


---
# Validation du cours

## DM

**Objectif**: manipulation de donn√©es sur `R`, intuition, quelques r√©gressions

√Ä faire seul(e) ou √† deux

**√Ä rendre pour le 10 Janvier 23h59**

&amp;nbsp;

## M√©moire


---
# Cette s√©ance

&amp;nbsp;

1. La recherche en √©conomie empirique

2. `R`: Rappels 

  2.1. D√©finition, usages, interface  
  2.2. Projet `R`   
  2.3. Importer des donn√©es   
  2.4. Manipulation des donn√©es avec `dplyr`   
  2.5. Visualisation des donn√©es avec `ggplot`   
  2.6. Maps
  
---
# 1. La recherche en √©conomie empirique

### Qu'est-ce que la recherche en √©conomie empirique?

- R√©pondre √† des **questions de recherche** pour apprendre sur les comportements humains, l'efficacit√© des poliques publiques, ...   

--

  - Quel est l'effet des bourses de scolarit√© **sur** la r√©ussite scolaire? 

  - Quel est l'effet d'un allongement de la dur√©e du cong√© parental **sur** la participation au march√© du travail des m√®res?

  - Quelle est l'ampleur de la discrimination dans le processus de recrutement?

  - Quel est l'effet d'un assouplissement des conditions d'√©ligibilit√© √† l'assurance ch√¥mage **sur** l'emploi?

  - Quel est l'effet de la pollution atmosph√©rique **sur** la productivit√©?  

  - Quel est le r√¥le des m√©dias **sur** le comportement de vote?

  - Quel est l'effet de la densit√© de population **sur** les salaires?

---
# 1. La recherche en √©conomie empirique

### Qu'est-ce que la recherche en √©conomie empirique?

- R√©pondre √† des **questions de recherche** pour apprendre sur les comportements humains, l'efficacit√© des poliques publiques, ...

  - Grande diversit√© des champs de recherche: √©ducation, travail, famille, environnement, macro√©conomie, politique, migration, genre, urban, crime, √©conomie historique, ...
  
  
- ... en utilisant des techniques statistiques rigoureuses (= **√©conom√©trie**) ...

- ... une strat√©gie/un cadre qui nous permet d'identifier un **effet causal**...

- ... et des donn√©es!


- `R` est un logiciel qui permet de r√©aliser ces analyses descriptives et empiriques.

---
layout: false
class: center, middle, inverse

# 2. `R`: rappels

---
# 2. `R`: rappels

## 2.1. D√©finition, usages, interface


- D'apr√®s le site internet de `R` : *R is a free software environment for statistical computing and graphics.*

  - un logiciel (interface R studio)
  
  - un language de programmation
  
- `R` est **gratuit** et en **open source**

  - donc tr√®s utilis√© dans les milieux acad√©mique et institutionnel

- Logiciel tr√®s **polyvalent**

  - statistiques decriptives, analyses √©conom√©triques, analyse de donn√©es spaciales, ML, Rmarkdown

- Comp√©tence valoris√©e et de plus en plus recherch√©e (public &amp; priv√©)   


---
### Popularit√© de `R`&lt;sup&gt;1&lt;/sup&gt;

.pull-left[
&lt;img src="imgs/popularity_datascientist.jpg" width="90%" style="display: block; margin: auto;" /&gt;
]

.pull-right[
&lt;img src="imgs/popularity_scholar.png" width="80%" style="display: block; margin: auto;" /&gt;
]

.footnote[
[1]: [The Popularity of Data Science Software](https://r4stats.com/articles/popularity/)
]

---
# 2. `R`: rappels

## 2.1. D√©finition, usages, interface

&lt;img src="imgs/interface.png" width="70%" style="display: block; margin: auto;" /&gt;


---
# 2. `R`: rappels

## 2.2. Projet `R`

Les projets `R` permettent une meilleure organisation de votre travail.

.pull-left[
&lt;img src="imgs/rproj.jpeg" width="50%" style="display: block; margin: auto;" /&gt;
]

.pull-right[
**Cr√©ation d'un projet `R`:** 
- Dans R-Studio  

  - Fichier `\(\rightarrow\)` Nouveau projet  

]


---
background-color: #f19bb5
# Application: cr√©er votre projet `R`

<div class="countdown" id="timer_b810067b" data-update-every="1" tabindex="0" style="top:0;right:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">03</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

.pull-left[
&lt;img src="imgs/rproj_sans_fond.png" width="70%" style="display: block; margin: auto;" /&gt;
]

.pull-right[
- Cr√©er un projet R pour la Lecture 1 en respectant cette structure

- Cr√©er un nouveau script R, enregistr√© dans le dossier lecture_1
]



---
# 2. `R`: rappels

## 2.3. Importer des donn√©es

**Format .csv:**

- `read.csv()` ou `read.cvs2()` avec l'argument `sep = ';'`

&amp;nbsp;

**Formats .dta (stata), .sas7bdat (sas): ** package `haven` (nb: `haven` est inclus dans `tidyverse`)

  - `.dta` : `read_dta()`
  
  - `.sas7dbat` : `read_sas()`
  
&amp;nbsp;

**Format .xls ou .xlsx (Excel): ** package `readxl`

  - `read_excel()`  
  
---
# 2. `R`: rappels

## 2.3. Importer des donn√©es

&amp;nbsp;

**Format .rds:** format de donn√©es le moins lourd et optimal pour travailler sur R, surtout quand les bases de donn√©es sont tr√®s volumineuses

- `readRDS()`

&amp;nbsp;

**Conseil**: √† la fin du script de cleaning, enregistrer le ou les data.frames nettoy√©s en format `.RDS` avec la fonction `saveRDS()` et importer ces donn√©es nettoy√©es dans le script sur lequel vous ferez toutes vos analyses.
  
  
---
background-image: url(imgs/dplyr_logo.png)
background-position: 90% 10%
background-size: 15%

# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`


Principal package pour la manipulation de donn√©es : `dplyr`

`$$\text{data.frame} \;\; \underbrace{\text{%&gt;%}}_{\text{pipe}} \;\; \text{function}(\text{your action})$$`

--
### Principales fonctions 

- `mutate()`: cr√©er ou modifier des variables
- `summarise()`: r√©sume les donn√©es par des statistiques descriptives 
- `filter()`: conserve ou supprime les lignes 
- `group_by()`: permet de grouper des observations entre elles 
- `select()`: conserve ou supprime des colonnes
- `arrange()`: ordonne les observations par rapport aux valeurs d'une colonne



---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Op√©rateurs 

&amp;nbsp;

.pull-left[
| Op√©rateur **arithm√©tiques**  | Description               |
|------------------------------|---------------------------|
| `+` / `-`                    | Addition / Soustraction   |
| `*` / `/`                    | Multiplication / Division |
| `^`                          | Exposant                  |
]

.pull-right[
| Op√©rateur **logiques**  | Description                          |
|-------------------------|--------------------------------------|
| `&lt;` / `&gt;`               | Strictement inf√©rieur / sup√©rieur √†  |
| `&lt; =` / `&gt; =`           | Sup√©rieur / inf√©rieur ou √©gal √†      |
| `= =`                   | √âgal √†                               |
| `! =`                   | Diff√©rent de                         |
| `x %in% c(1,6)`         | `\(x\)` dans `\(\{1,6\}\)`                   |
| `x &amp; y`                 | `\(x\)` *et* `\(y\)`                         |
| &lt;code&gt;x &amp;#124; y&lt;/code&gt; | `\(x\)` *ou* `\(y\)`                         |
]

---
background-color: #f19bb5
# Application : Titanic

Ce jeu de donn√©es fournit des informations sur le sort des passagers du paquebot ¬´ Titanic ¬ª, r√©sum√©es en fonction du statut √©conomique (class), du sexe, de l'√¢ge et de la survie.


``` r
titanic = as.data.frame(Titanic)

head(titanic)
```

```
##   Class    Sex   Age Survived Freq
## 1   1st   Male Child       No    0
## 2   2nd   Male Child       No    0
## 3   3rd   Male Child       No   35
## 4  Crew   Male Child       No    0
## 5   1st Female Child       No    0
## 6   2nd Female Child       No    0
```

---
background-color: #f19bb5
# Application : Titanic

<div class="countdown" id="timer_bd4f178d" data-update-every="1" tabindex="0" style="top:0;right:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">05</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

&amp;nbsp;


1) Calculer le taux de survie par classe, par sexe, et par √¢ge

2) Cr√©er une variable `passenger` qui vaut 1 si l'individu n'est pas un membre d'√©quipage (*crew*), 0 si c'est un membre d'√©quipage

3) Cr√©er une table qui r√©sume, pour les adultes uniquement, le taux de survie par Classe x Sexe et ordonner par ordre d√©croissant

---
background-color: #fbe6ec
# Solution : Titanic

1) Calculer le taux de survie par classe, par sexe, et par √¢ge


``` r
titanic %&gt;% 
* group_by(Class) %&gt;%
  summarise(tx_survie = sum(Freq[Survived == "Yes"])/sum(Freq)) %&gt;% 
  ungroup()
```

```
## # A tibble: 4 √ó 2
##   Class tx_survie
##   &lt;fct&gt;     &lt;dbl&gt;
## 1 1st       0.625
## 2 2nd       0.414
## 3 3rd       0.252
## 4 Crew      0.240
```

---
background-color: #fbe6ec
count: false
# Solution : Titanic

1) Calculer le taux de survie par classe, par sexe, et par √¢ge


``` r
titanic %&gt;% 
  group_by(Class) %&gt;% 
* summarise(tx_survie = sum(Freq[Survived == "Yes"])/sum(Freq)) %&gt;%
  ungroup()
```

```
## # A tibble: 4 √ó 2
##   Class tx_survie
##   &lt;fct&gt;     &lt;dbl&gt;
## 1 1st       0.625
## 2 2nd       0.414
## 3 3rd       0.252
## 4 Crew      0.240
```

---
background-color: #fbe6ec
# Solution : Titanic

1) Calculer le taux de survie par classe, par sexe, et par √¢ge


``` r
titanic %&gt;% 
  group_by(Sex) %&gt;% 
  summarise(tx_survie = sum(Freq[Survived == "Yes"])/sum(Freq)) %&gt;% 
  ungroup()
```

```
## # A tibble: 2 √ó 2
##   Sex    tx_survie
##   &lt;fct&gt;      &lt;dbl&gt;
## 1 Male       0.212
## 2 Female     0.732
```


---
background-color: #fbe6ec
# Solution : Titanic

1) Calculer le taux de survie par classe, par sexe, et par √¢ge


``` r
titanic %&gt;% 
  group_by(Age) %&gt;% 
  summarise(tx_survie = sum(Freq[Survived == "Yes"])/sum(Freq)) %&gt;% 
  ungroup()
```

```
## # A tibble: 2 √ó 2
##   Age   tx_survie
##   &lt;fct&gt;     &lt;dbl&gt;
## 1 Child     0.523
## 2 Adult     0.313
```


---
background-color: #fbe6ec
# Solution : Titanic

2) Cr√©er une variable `passenger` qui vaut 1 si l'individu n'est pas un membre d'√©quipage (*crew*), 0 si c'est un membre d'√©quipage


``` r
# Solution 1
titanic %&gt;% 
  mutate(passenger = ifelse(Class != "Crew", 1, 0))

# Solution 2
titanic %&gt;% 
  mutate(passenger = case_when(Class != "Crew" ~ 1,
                               Class == "Crew" ~ 0))
```

**Conseil**: utiliser `case_when` quand il y a plus d'une condition.

---
background-color: #fbe6ec
# Solution : Titanic

3) Cr√©er une table qui r√©sume, pour les adultes uniquement, le taux de survie par Classe x Sexe et ordonner par ordre d√©croissant


``` r
titanic %&gt;%
  filter(Age == "Adult") %&gt;%
  group_by(Class, Sex) %&gt;%
  summarise(tx_survie = sum(Freq[Survived == "Yes"]) / sum(Freq)) %&gt;%
  arrange(desc(tx_survie))
```

---
count: false
background-color: #fbe6ec
# Solution : Titanic

3) Cr√©er une table qui r√©sume, **pour les adultes uniquement**, le taux de survie par Classe x Sexe et ordonner par ordre d√©croissant


``` r
titanic %&gt;%
* filter(Age == "Adult") %&gt;%
  group_by(Class, Sex) %&gt;%
  summarise(tx_survie = sum(Freq[Survived == "Yes"]) / sum(Freq)) %&gt;%
  arrange(desc(tx_survie))
```

---
count: false
background-color: #fbe6ec
# Solution : Titanic

3) Cr√©er une table qui r√©sume, pour les adultes uniquement, le taux de survie par **Classe x Sexe** et ordonner par ordre d√©croissant


``` r
titanic %&gt;%
  filter(Age == "Adult") %&gt;%
* group_by(Class, Sex) %&gt;%
  summarise(tx_survie = sum(Freq[Survived == "Yes"]) / sum(Freq)) %&gt;%
  arrange(desc(tx_survie))
```

---
count: false
background-color: #fbe6ec
# Solution : Titanic

3) Cr√©er une table qui r√©sume, pour les adultes uniquement, le **taux de survie** par Classe x Sexe et ordonner par ordre d√©croissant


``` r
titanic %&gt;%
  filter(Age == "Adult") %&gt;%
  group_by(Class, Sex) %&gt;%
* summarise(tx_survie = sum(Freq[Survived == "Yes"]) / sum(Freq)) %&gt;%
  arrange(desc(tx_survie))
```


---
count: false
background-color: #fbe6ec
# Solution : Titanic

3) Cr√©er une table qui r√©sume, pour les adultes uniquement, le taux de survie par Classe x Sexe et **ordonner par ordre d√©croissant**


``` r
titanic %&gt;%
  filter(Age == "Adult") %&gt;%
  group_by(Class, Sex) %&gt;%
  summarise(tx_survie = sum(Freq[Survived == "Yes"]) / sum(Freq)) %&gt;%
* arrange(desc(tx_survie))
```

```
## # A tibble: 8 √ó 3
## # Groups:   Class [4]
##   Class Sex    tx_survie
##   &lt;fct&gt; &lt;fct&gt;      &lt;dbl&gt;
## 1 1st   Female    0.972 
## 2 Crew  Female    0.870 
## 3 2nd   Female    0.860 
## 4 3rd   Female    0.461 
## 5 1st   Male      0.326 
## 6 Crew  Male      0.223 
## 7 3rd   Male      0.162 
## 8 2nd   Male      0.0833
```


---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

.center[
&lt;img src="imgs/datasets.png" width="40%" style="display: block; margin: auto;" /&gt;
]

- Tr√®s souvent, les donn√©es n√©cessaires √† l'analyse sont issues de plusieurs sources   

- Joindre deux tables de donn√©es peut permettre d'ajouter 
  - des variables suppl√©mentaires
  - des observations suppl√©mentaires
  
- L'ajout de variables peut se faire sur la base:
  - de la position des observations dans les deux jeux de donn√©es: **binding joints**
  - relativement aux valeurs d'une ou plusieurs autres colonnes, les *cl√©s*: **mutating joints**


---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Binding joints 

.center[
**Binding Rows**
&lt;img src="imgs/little_datasets.png" width="45%" style="display: block; margin: auto;" /&gt;
]


.left-column[
&lt;img src="imgs/bindrows.jpeg" width="80%" style="display: block; margin: auto;" /&gt;
]
.right-column[
`bind_rows(a, b)`: dans une jointure de lignes, les colonnes sont associ√©es √† leur nom et toute colonne manquante est remplac√©e par NA.
]


---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Binding joints 

.center[
**Binding Columns**
&lt;img src="imgs/little_datasets.png" width="45%" style="display: block; margin: auto;" /&gt;
]


.left-column[
&lt;img src="imgs/bindcols.jpeg" width="90%" style="display: block; margin: auto;" /&gt;
]
.right-column[
`bind_cols(a, b)`: dans une jointure de colonnes, les lignes sont mises en correspondance en fonction de leur **position**
]


---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Mutating joints 


.center[
**Left-joint**
&lt;img src="imgs/little_datasets.png" width="45%" style="display: block; margin: auto;" /&gt;
]


.left-column[
&lt;img src="imgs/left_joint.jpeg" width="80%" style="display: block; margin: auto;" /&gt;
]
.right-column[
`left_join(a, b, by = "x1")`: pour chaque ligne de **a** on a ajout√© les colonnes de **b** pour lesquelles la valeur de la *cl√©* **x1** est la m√™me
]



---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Mutating joints 

.center[
**Right-joint**
&lt;img src="imgs/little_datasets.png" width="45%" style="display: block; margin: auto;" /&gt;
]


.left-column[
&lt;img src="imgs/right_joint.jpeg" width="80%" style="display: block; margin: auto;" /&gt;
]
.right-column[
`right_join(a, b, by = "x1")`: pour chaque ligne de **b** on a ajout√© les colonnes de **a** pour lesquelles la valeur de la *cl√©* **x1** est la m√™me
]


---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Mutating joints 

.center[
**Inner-joint**
&lt;img src="imgs/little_datasets.png" width="45%" style="display: block; margin: auto;" /&gt;
]


.left-column[
&lt;img src="imgs/inner_joint.jpeg" width="80%" style="display: block; margin: auto;" /&gt;
]
.right-column[
`inner_join(a, b, by = "x1")`: seules les lignes pr√©sentes √† la fois dans **a** et **b** sont jointes
]


---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Mutating joints 

.center[
**Full-joint**
&lt;img src="imgs/little_datasets.png" width="45%" style="display: block; margin: auto;" /&gt;
]


.left-column[
&lt;img src="imgs/full_joint.jpeg" width="80%" style="display: block; margin: auto;" /&gt;
]
.right-column[
`full_join(a, b, by = "x1")`: toutes les lignes de **a** et toutes les lignes de **b** sont jointes (avec des NA ajout√©s si n√©cessaire) m√™me si elles sont absentes de l‚Äôautre table
]




---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Formats wide et long

Pour **rassembler des colonnes** et passer en format **long**: `pivot_longer`

.center[
&lt;img src="imgs/longer.png" width="40%" style="display: block; margin: auto;" /&gt;
]

&amp;nbsp;

`b = pivot_longer(a, cols = 2:3,  names_to = "grade", values_to = "mean")`
       
       
 
---
# 2. `R`: rappels

## 2.4. Manipulation des donn√©es avec `dplyr`

### Formats wide et long

Pour **disperser des lignes** et obtenir un format **wide**: `pivot_wider`

.center[
&lt;img src="imgs/wider.png" width="50%" style="display: block; margin: auto;" /&gt;
]

`b = pivot_wider(a,  names_from = subject, values_from = mean)`      


---
background-color: #f19bb5
# Application : L√©gislatives 2024 

&amp;nbsp;

**Utilisation de 3 bases de donn√©es:**
- r√©sultats au premier tour: `resultats-definitifs-par-circonscription-t1.csv`
- r√©sultats au second tour: `resultats-definitifs-par-circonscription-t2.csv`
- population par circonscription en 2019: `population_2019.csv`

Chaque observation = une circonscription

Les bases de *donn√©es des r√©sultats aux √©lections sont en format wide*:
- chaque circonscription √† un nombre fini de candidats (jusqu'√† 19 candidats)
- les informations relatives aux diff√©rents candidats (nom, sexe, parti politique, etc) sont renseign√©es dans diff√©rentes variables
- les variables relatives au m√™me candidat ont le m√™me suffixe (eg Nom.candidat.1, Nuance.candidat.1, ...)



---
background-color: #f19bb5
# Application : L√©gislatives 2024 

üö® **Encodage du libell√© des circonscriptions**




``` r
head(resultats_t1[1:4,c(2,4)])
```

```
##   Libell√©.d√©partement Libell√©.circonscription.l√©gislative
## 1                 Ain                1√®re circonscription
## 2                 Ain                2√®me circonscription
## 3                 Ain                3√®me circonscription
## 4                 Ain                4√®me circonscription
```

``` r
head(pop_2019)[1:4,]
```

```
##   X. Circonscriptions Population.20191...hab..
## 1  1         Ain, 1re                   122750
## 2  2          Ain, 2e                   137975
## 3  3          Ain, 3e                   146110
## 4  4          Ain, 4e                   128896
```

**Variables Cl√©s**: `Libell√©.d√©partement` qui comprend uniquement le nom du d√©partement, et `Libell√©.circonscription` qui contient uniquement le num√©ro de la circonscription.

---
background-color: #f19bb5
# Application : L√©gislatives 2024 

üö® **Encodage du libell√© des circonscriptions**



``` r
resultats_t1 = resultats_t1 %&gt;% 
  mutate(Libell√©.circonscription.l√©gislative = gsub("\\D", "", Libell√©.circonscription.l√©gislative))

unique(resultats_t1$Libell√©.circonscription.l√©gislative)  
```

```
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15"
## [16] "16" "17" "18" "19" "20" "21"
```



&amp;nbsp;


`$$\underbrace{ \text{gsub}}_{\text{remplace}}( \underbrace{ \text{"\\\D"}}_{\substack{\text{tout ce qui n'est} \\  \text{pas num√©rique}}}  , \underbrace{\text{""}}_{\substack{\text{par une cha√Æne} \\ \text{de caract√®res vide}}},  \underbrace{\text{Libell√©.circonscription.l√©gislative}}_{\substack{\text{dans la variable} \\ \text{Libell√©.circonscription.l√©gislative}}})$$`


---
background-color: #f19bb5
# Application : L√©gislatives 2024 

üö® **Encodage du libell√© des circonscriptions**



``` r
pop_2019 = pop_2019 %&gt;% 
  separate(Circonscriptions, into = c("Libell√©.d√©partement", "Libell√©.circonscription.l√©gislative"), sep = ", ") %&gt;% 
  mutate(Libell√©.circonscription.l√©gislative = gsub("\\D", "", Libell√©.circonscription.l√©gislative))

unique(pop_2019$Libell√©.circonscription.l√©gislative)  
```

```
##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13" "14" "15"
## [16] "16" "17" "18" "19" "20" "21"
```

&amp;nbsp;


`$$\underbrace{ \text{separate}}_{\text{s√©pare}}( \underbrace{ \text{"Circonscriptions"}}_{\substack{\text{les caract√®res de la} \\ \text{variable Circonscriptions}}}  , \underbrace{\text{into = c("A", "B")}}_{ \substack{ \text{en deux cha√Ænes de caract√®res} \\ \text{qui d√©finissent ces deux variables}}},  \underbrace{\text{ sep = ", "}}_{\substack{\text{la s√©paration √©tant} \\ \text{faite √† l'endroit de} \\ \text{la virgule}}})$$`

---
background-color: #f19bb5
# Application : L√©gislatives 2024 

<div class="countdown" id="timer_1c7cf1b2" data-update-every="1" tabindex="0" style="top:0;right:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

1) Importer les donn√©es (nommer les dataframes `resultats_t1`, `resultats_t2` et `pop_2019`)

2) Effectuer sur chaque jeu de donn√©es les op√©rations n√©cessaires pour harmoniser l'encodage du libell√© de circonscription   
  - **pop-19**: `separate(Circonscriptions, into = c("Libell√©.d√©partement", "Libell√©.circonscription.l√©gislative"), sep = ", ")`    
  - **resultats_t1** et **resultats_t2** et **pop_2019**: `gsub("\\D", "", Libell√©.circonscription.l√©gislative)`

3) Reformatter `resultats_t1` et `resultats_t2`  en format long (chaque observation = un candidat)

4) Ajouter une variable `tour` qui vaut 1 dans `resultats_t1` et 2 dans `resultats_t2`

5) Ajouter les observations de `resultats_t2` √† `resultats_t1` et stocker le tout dans `resultats`

6) Ne conserver que les observations des candidats √©lus

7) Joindre `pop_2019` √† `resultats` et renommer `Population.20191...hab..` en `pop`



---
background-color: #fbe6ec
# Solution

1) Importer les donn√©es


``` r
resultats_t1 = read.csv("data/resultats-definitifs-par-circonscription-t1.csv", sep = ";", na.strings=c("","NA")) 
resultats_t2 = read.csv("data/resultats-definitifs-par-circonscription-t2.csv", sep = ";", na.strings=c("","NA")) 
pop_2019 = read.csv("data/population_2019.csv", sep = ";")
```


2) Effectuer sur chaque jeu de donn√©es les op√©rations n√©cessaires pour harmoniser l'encodage du libell√© de circonscription   


``` r
resultats_t1 = resultats_t1 %&gt;% 
  mutate(Libell√©.circonscription.l√©gislative = gsub("\\D", "", Libell√©.circonscription.l√©gislative))

resultats_t2 = resultats_t2 %&gt;% 
  mutate(Libell√©.circonscription.l√©gislative = gsub("\\D", "", Libell√©.circonscription.l√©gislative))

pop_2019 = pop_2019 %&gt;% 
  separate(Circonscriptions, into = c("Libell√©.d√©partement", "Libell√©.circonscription.l√©gislative"), sep = ", ") %&gt;% 
  mutate(Libell√©.circonscription.l√©gislative = gsub("\\D", "", Libell√©.circonscription.l√©gislative))
```

---
background-color: #fbe6ec
# Solution

3) Reformatter `resultats_t1` et `resultats_t2`  en format long

4) Ajouter une variable `tour` qui vaut 1 dans `resultats_t1` et 2 dans `resultats_t2`



``` r
resultats_t1_long = resultats_t1 %&gt;%
  pivot_longer(
*   cols = matches(".*\\.[1-9]$|.*\\.[1][0-9]$"),
    names_to = c(".value", "candidate_number"), 
    names_pattern = "(.*)\\.(\\d+)" 
  ) %&gt;%
  mutate(tour = 1) 
```

**Explication**:
- `cols = matches(".*\\.[1-9]$|.*\\.[1][0-9]$")`: S√©lectionne les colonnes dont le nom termine par un point suivi d'un nombre de 1 √† 19        



---
count: false
background-color: #fbe6ec
# Solution

3) Reformatter `resultats_t1` et `resultats_t2`  en format long

4) Ajouter une variable `tour` qui vaut 1 dans `resultats_t1` et 2 dans `resultats_t2`



``` r
resultats_t1_long = resultats_t1 %&gt;%
  pivot_longer(
    cols = matches(".*\\.[1-9]$|.*\\.[1][0-9]$"),  
*   names_to = c(".value", "candidate_number"),
    names_pattern = "(.*)\\.(\\d+)" 
  ) %&gt;%
  mutate(tour = 1) 
```

**Explications**:
- `names_to = c(".value", "candidate_number")`: d√©finie le **nom** des nouvelles variables      
  - `.value` cr√©e de nouvelles variables dont le nom correspond √† ce qui pr√©c√®de le point pour chaque variable ayant un suffixe num√©rique         
  - `candidate_number` cr√©e une nouvelle colonne qui contient les suffixes num√©riques (1 √† 19) indiquant le num√©ro du candidat



---
count: false
background-color: #fbe6ec
# Solution

3) Reformatter `resultats_t1` et `resultats_t2`  en format long

4) Ajouter une variable `tour` qui vaut 1 dans `resultats_t1` et 2 dans `resultats_t2`



``` r
resultats_t1_long = resultats_t1 %&gt;%
  pivot_longer(
    cols = matches(".*\\.[1-9]$|.*\\.[1][0-9]$"),  
    names_to = c(".value", "candidate_number"), 
*   names_pattern = "(.*)\\.(\\d+)"
  ) %&gt;%
  mutate(tour = 1) 
```

**Explications**:

- `names_pattern = "(.*)\\.(\\d+)"`: utilise une expression r√©guli√®re pour **s√©parer** les noms de colonnes en deux parties:    
  - `(.*)` capture tout ce qui pr√©c√®de le point et l‚Äôassigne √† `.value`       
  - `(\\d+)` capture les nombres apr√®s le point et les assigne √† `candidate_number`      




---
background-color: #fbe6ec
# Solution

3) Reformatter `resultats_t1` et `resultats_t2`  en format long

4) Ajouter une variable `tour` qui vaut 1 dans `resultats_t1` et 2 dans `resultats_t2`

**On reproduit les m√™mes op√©rations sur `resultats_t2` (sauf que cette fois-ci il y a au maximum 4 candidats par circonscription)**


``` r
resultats_t2_long = resultats_t2 %&gt;%
  pivot_longer(
*   cols = matches(".*\\.[1-4]$"),
    names_to = c(".value", "candidate_number"),
    names_pattern = "(.*)\\.(\\d+)"
  ) %&gt;%
  mutate(tour = 2) 
```


---
background-color: #fbe6ec
# Solution

5) Ajouter les observations de `resultats_t2` √† `resultats_t1` et stocker le tout dans `resultats`      

6) Ne conserver que les observations des candidats √©lus

7) Joindre `pop_2019` √† `resultats` et renommer `Population.20191...hab..` en `pop`



``` r
resultats = bind_rows(resultats_t1_long, resultats_t2_long) %&gt;% 
  filter(Elu == "√©lu") %&gt;% 
  left_join(pop_2019 %&gt;% rename(pop = Population.20191...hab..), by = c("Libell√©.d√©partement", "Libell√©.circonscription.l√©gislative"))
```



---
background-image: url(imgs/ggplot2_logo.png)
background-position: 95% 5%
background-size: 10%

# 2. `R`: rappels

## 2.5. Visualisation des donn√©es avec `ggplot2`

 &amp;nbsp;

`ggplot2` est un package `R` qui permet de **visualiser des donn√©es** sous forme de graphiques.    

Afin de *cha√Æner* des op√©rations, c'est √† dire d'**ajouter des couches au graphique, on utilise les `+`**
 (l'√©quivalent de ` %&gt;% ` avec `dplyr`).   
 
 
Pour consturire n'importe quel graphique, il faut:
- une base de donn√©es
- lier les variables aux √©lements graphiques (axes, couleurs, tailles) via l'argument `aes()`
- d√©finir un type de graphique (ligne, point, histogramme, densit√©, etc)

### Structure de base


``` r
ggplot(data, 
       aes(x = x, y = y)) + 
  geom_point()
```


---
# 2. `R`: rappels

## 2.5. Visualisation des donn√©es avec `ggplot2`

### Principales fonctions 

- `ggplot()` : Initialiser un graphique en sp√©cifiant les donn√©es et les aesthetics    

- `geom_` : Repr√©sente les types de graphiques:   
  - `geom_point()` pour un nuage de points   
  - `geom_line()` pour des lignes   
  - `geom_bar() `pour un histogramme/barplot   
  - `geom_density()` pour une densit√©    
  
- `labs()` : Ajouter des titres et l√©gendes    

- `theme()` : Personnaliser l'apparence du graphique    

 &amp;nbsp;


---
# 2. `R`: rappels

## 2.5. Visualisation des donn√©es avec `ggplot2`

### Variable _discr√®te_

.pull-left[

``` r
ggplot(resultats, 
       aes(x = Nuance.candidat)) + 
  geom_bar() +
  labs(
    title = "Nombre de si√®ges par parti",
    x = "Parti",
    y = "Nombre de si√®ges") +
  theme_minimal()
```
]

.pull-right[
&lt;img src="lecture_1_fr_files/figure-html/unnamed-chunk-26-1.svg" style="display: block; margin: auto;" /&gt;
]

---
count: false
# 2. `R`: rappels

## 2.5. Visualisation des donn√©es avec `ggplot2`

### Variable _discr√®te_

.pull-left[

``` r
resultats %&gt;%
* count(Nuance.candidat) %&gt;%
* mutate(percentage = n/sum(n)*100) %&gt;%
  ggplot(aes(x = Nuance.candidat, 
*            y = percentage)) +
* geom_bar(stat = "identity") +
  labs(
    title = "Proportion de si√®ges par parti",
    x = "Parti",
    y = "Proportion de si√®ges") +
  theme_minimal() 
```

La fonction `count()` compte le nombre d'observation par groupe `Nuance.candidat` et stocke cette information dans une nouvelle variable, `n` (√©quivaut √† `group_by(Nuance.candidat) %&gt;% summarize(n = n())`)
]

.pull-right[
&lt;img src="lecture_1_fr_files/figure-html/unnamed-chunk-28-1.svg" style="display: block; margin: auto;" /&gt;
]

---
# 2. `R`: rappels

## 2.5. Visualisation des donn√©es avec `ggplot2`

### Variable _discr√®te_

.pull-left[

``` r
ggplot(resultats, 
*      aes(x = Nuance.candidat, fill = Sexe.candidat)) +
  geom_bar() +
  labs(
    title = "Nombre de si√®ges par parti",
    x = "Parti",
    y = "Nombre de si√®ges") +
   theme_minimal() +
   theme(legend.position="bottom")
```
]

.pull-right[
&lt;img src="lecture_1_fr_files/figure-html/unnamed-chunk-30-1.svg" style="display: block; margin: auto;" /&gt;
]

---
# 2. `R`: rappels

## 2.5. Visualisation des donn√©es avec `ggplot2`

### Variable _continue_

.pull-left[

``` r
resultats %&gt;% 
    mutate(Blancs = as.numeric(Blancs)/100) %&gt;% 
    ggplot(aes(x = Blancs)) + 
    geom_density() +
    labs(
        title = "Distribution des votes blancs",
        x = "Votes blancs (en centaines)",
        y = "Fr√©quence") +
    theme_minimal() 
```
]

.pull-right[
&lt;img src="lecture_1_fr_files/figure-html/unnamed-chunk-32-1.svg" style="display: block; margin: auto;" /&gt;
]



---
# 2. `R`: rappels

## 2.5. Visualisation des donn√©es avec `ggplot2`

### `facet_wrap`

.pull-left[

``` r
resultats %&gt;%
* group_by(Nuance.candidat) %&gt;%
  count(Sexe.candidat) %&gt;% 
  mutate(percentage = n/sum(n)*100) %&gt;% 
  ggplot(aes(x = Sexe.candidat, 
             y = percentage)) + 
  geom_bar(stat = "identity") + 
  labs(
    title = "Proportion de si√®ges par parti",
    x = "Parti",
    y = "Proportion de si√®ges") +
* facet_wrap( ~ Nuance.candidat) +
  theme_minimal() 
```
]

.pull-right[
&lt;img src="lecture_1_fr_files/figure-html/unnamed-chunk-34-1.svg" style="display: block; margin: auto;" /&gt;
]



---
# 2. `R`: rappels

## 2.6. Visualisation des donn√©es spaciales

### Format de cartes et donn√©es


&lt;img src="imgs/spacialdata.png" width="75%" style="display: block; margin: auto;" /&gt;



Tr√®s bonne r√©f√©rence: [G√©omatique sur R](https://rcarto.github.io/geomatique_avec_r/)


---
count:false
# 2. `R`: rappels

## 2.6. Visualisation des donn√©es spaciales

### Format de cartes et donn√©es

&lt;img src="imgs/sf.png" width="75%" style="display: block; margin: auto;" /&gt;

Tr√®s bonne r√©f√©rence: [G√©omatique sur R](https://rcarto.github.io/geomatique_avec_r/)


---
background-image: url(imgs/sflogo.png)
background-position: 95% 10%
background-size: 15%

# 2. `R`: rappels

## 2.6. Visualisation des donn√©es spaciales

**Package `sf`**


**Shapefile**: format de fichier g√©ospatial utilis√© pour repr√©senter des entit√©s g√©ographiques
- contient des informations sur la forme (polygones, points, lignes) et des attributs.
- compos√© de plusieurs fichiers `.shp`, `.shx`, `.dbf`, tous n√©cessaires pour la r√©alisation de cartes


Une fois import√©s sur `R`, les objets `sf` sont des `data.frame` dont l‚Äôune des colonnes contient des g√©om√©tries.





``` r
head(map[ , -c(5,6)],3)
```

```
## Simple feature collection with 3 features and 4 fields
## Geometry type: MULTIPOLYGON
## Dimension:     XY
## Bounding box:  xmin: -0.595231 ymin: 44.80615 xmax: 5.889757 ymax: 50.7899
## Geodetic CRS:  WGS 84
##      ID Code.d√©partement code_reg nom_dpt                       geometry
## 1 33004               33       75 GIRONDE MULTIPOLYGON (((-0.454946 4...
## 2 38001               38       84   ISERE MULTIPOLYGON (((5.805288 45...
## 3 59010               59       32    NORD MULTIPOLYGON (((3.058745 50...
```




---
# 2. `R`: rappels

## 2.6. Visualisation des donn√©es spaciales

**R√©aliser une carte en 3 √©tapes**

1. Importer les donn√©es    
  - Le jeu de donn√©es qui contient l'information √† visualiser   
  - Les fichiers `shapefiles` qui contiennent le fond de carte, etc, avec la fonction `st_read()`    
    - üö®: on importe sur `R` uniquement le fichier `.shp`, mais tous les autres fichiers (`.shx`, `.dbf`, etc) t√©l√©charg√©s avec le *shapefile* doivent √™tre localis√©s au m√™me endroit que le `.shp`   
    
2. Lier le jeu de donn√©es qui contient l'information √† visualiser avec les donn√©es g√©ographiques  
  - Pour ajouter de l'information √† un fond de carte, il est n√©cessaire de disposer d'une **variable (*key*) g√©ographique commune entre les deux fichiers**

3. Repr√©senter la carte avec la fonction `geom_sf()`  sur le m√™me principe que `geom_line()` par exemple avec `ggplot2`     
  - Ici, l'esth√©tique du graphique (`aes`) comprend un nouvel argument, `geometry`, qui doit √™tre √©gal √† la variable contenant les donn√©es g√©ographiques
 

---
background-color: #f19bb5
# Application: carte r√©sultats l√©gislatives

<div class="countdown" id="timer_5e4ab49b" data-update-every="1" tabindex="0" style="top:0;right:0;">
<div class="countdown-controls"><button class="countdown-bump-down">&minus;</button><button class="countdown-bump-up">&plus;</button></div>
<code class="countdown-time"><span class="countdown-digits minutes">10</span><span class="countdown-digits colon">:</span><span class="countdown-digits seconds">00</span></code>
</div>

**Importer les donn√©es**     
1) Importer `france-circonscriptions-legislatives-2012.shp`, que vous stockerez dans `maps`      

**Cleaning**      
2) Renommer `code_dpt` en `Code.d√©partement` et `num_circ` en `Libell√©.circonscription`       
3) Modifier la variable `Code.d√©partement`: *si* le premier caract√®re est un `0`, `Code.d√©partement` prend la valeur du deuxi√®me carac√®re. *Sinon* pas de modification       

**Joindre les bases de donn√©es**         
4) Ajouter les informations de `map` √† `resultats` et stocker le tout dans `resultats_map`        

**R√©aliser une carte**       
5) R√©aliser la carte des r√©sultats des √©l√©ctions l√©gislatives de 2024       
*NB: ne pas s√©lectionner les d√©partements 971, 972, 973, 974, 975, 976, 986, 987, 988, ZX, ZZ qui correspondent aux DROM et qui ne sont pas sur ce fond de carte*      

---

background-color: #fbe6ec
# Solution

**Importer les donn√©es**     
1) Importer `france-circonscriptions-legislatives-2012.shp`, que vous stockerez dans `maps`    

**Cleaning**      
2) Renommer `code_dpt` en `Code.d√©partement` et `num_circ` en `Libell√©.circonscription`       
3) Modifier la variable `Code.d√©partement`: *si* le premier caract√®re est un `0`, `Code.d√©partement` prend la valeur du deuxi√®me carac√®re. *Sinon* pas de modification    


``` r
# Import data 
map = st_read("data/france-circonscriptions-legislatives-2012.shp", quiet = TRUE) %&gt;% 
  rename(Code.d√©partement = code_dpt,
         Libell√©.circonscription.l√©gislative = num_circ) %&gt;% 
  mutate(Code.d√©partement = ifelse(substr(Code.d√©partement, 1, 1) == "0", substr(Code.d√©partement, 2, 2), Code.d√©partement))
```



---
count: false
background-color: #fbe6ec
# Solution

**Importer les donn√©es**     
**1) Importer `france-circonscriptions-legislatives-2012.shp`, que vous stockerez dans `maps`**    

**Cleaning**      
2) Renommer `code_dpt` en `Code.d√©partement` et `num_circ` en `Libell√©.circonscription`       
3) Modifier la variable `Code.d√©partement`: *si* le premier caract√®re est un `0`, `Code.d√©partement` prend la valeur du deuxi√®me carac√®re. *Sinon* pas de modification    


``` r
# Import data 
*map = st_read("data/france-circonscriptions-legislatives-2012.shp", quiet = TRUE) %&gt;%
  rename(Code.d√©partement = code_dpt,
         Libell√©.circonscription.l√©gislative = num_circ) %&gt;% 
  mutate(Code.d√©partement = ifelse(substr(Code.d√©partement, 1, 1) == "0", substr(Code.d√©partement, 2, 2), Code.d√©partement))
```


---
count: false
background-color: #fbe6ec
# Solution

**Importer les donn√©es**     
1) Importer `france-circonscriptions-legislatives-2012.shp`, que vous stockerez dans `maps`    

**Cleaning**      
**2) Renommer `code_dpt` en `Code.d√©partement` et `num_circ` en `Libell√©.circonscription`**       
3) Modifier la variable `Code.d√©partement`: *si* le premier caract√®re est un `0`, `Code.d√©partement` prend la valeur du deuxi√®me carac√®re. *Sinon* pas de modification    


``` r
# Import data 
map = st_read("data/france-circonscriptions-legislatives-2012.shp", quiet = TRUE) %&gt;% 
* rename(Code.d√©partement = code_dpt,
*        Libell√©.circonscription.l√©gislative = num_circ) %&gt;%
  mutate(Code.d√©partement = ifelse(substr(Code.d√©partement, 1, 1) == "0", substr(Code.d√©partement, 2, 2), Code.d√©partement))
```

---
count: false
background-color: #fbe6ec
# Solution

**Importer les donn√©es**     
1) Importer `france-circonscriptions-legislatives-2012.shp`, que vous stockerez dans `maps`    

**Cleaning**      
2) Renommer `code_dpt` en `Code.d√©partement` et `num_circ` en `Libell√©.circonscription`       
**3) Modifier la variable `Code.d√©partement`: *si* le premier caract√®re est un `0`, `Code.d√©partement` prend la valeur du deuxi√®me carac√®re. *Sinon* pas de modification**    


``` r
# Import data 
map = st_read("data/france-circonscriptions-legislatives-2012.shp", quiet = TRUE) %&gt;% 
  rename(Code.d√©partement = code_dpt,
         Libell√©.circonscription.l√©gislative = num_circ) %&gt;% 
* mutate(Code.d√©partement = ifelse(substr(Code.d√©partement, 1, 1) == "0", substr(Code.d√©partement, 2, 2), Code.d√©partement))
```



---

background-color: #fbe6ec
# Solution

**Joindre les bases de donn√©es**         
4) Ajouter les informations de `map` √† `resultats` et stocker le tout dans `resultats_map`        



``` r
# Merge geographic data and results data
resultats_map = resultats %&gt;% 
* left_join(map , by = c("Code.d√©partement", "Libell√©.circonscription.l√©gislative"))
```


---

background-color: #fbe6ec
# Solution

**R√©aliser une carte**       
5) R√©aliser la carte des r√©sultats des √©l√©ctions l√©gislatives de 2024       
*NB: ne pas s√©lectionner les d√©partements 971, 972, 973, 974, 975, 976, 986, 987, 988, ZX, ZZ qui correspondent aux DROM et qui ne sont pas sur ce fond de carte*      


``` r
# Draw map
ggplot(resultats_map %&gt;% filter(! (Code.d√©partement %in% c("971", "972", "973", "974", "975", "976", "986", "987", "988", "ZX", "ZZ")))) +
  geom_sf(aes(fill = Nuance.candidat, geometry = geometry)) +
  theme_minimal() +
  scale_fill_manual(values = hcl.colors(14, "Purple-Yellow")) + 
  labs(title = "R√©sultats des √©lections l√©gislatives par circonscription",
       fill = "Parti") +
  theme(legend.position = "bottom", 
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank()) +
  guides(fill = guide_legend(nrow = 1)) 
```

---
background-color: #fbe6ec
# Solution


&lt;img src="lecture_1_fr_files/figure-html/carte r√©sultats-1.svg" style="display: block; margin: auto;" /&gt;


---
layout: false
class: center, middle, inverse

# Miscellaneous

---
name: bestfriend
# Vos 4 meilleurs amis


1. La **commande** `help(.)` ou `?.`

--

2. Les ***cheatsheets***
  - [Exemple](#cheatR)

--

3. **Internet** (stackoverflow): 

  - vous ne serez jamais la premi√®re personne √† rencontrer les probl√®mes auxquels vous faites face
  - copier/coller le message d'erreur peut suffire, mais essayez de comprendre par vous m√™me d'abord
  
--

4. **ChatGPT**: devient de plus en plus performant pour r√©soudre les probl√®mes de codes. 
  - ‚ö†Ô∏è souvent les packages ne sont pas √† jour, les fonctions propos√©es invent√©es

--

ü§ùÔ∏è Soyez autonomes: ne demander de l'aide √† vos camarades (ou √† moi) uniquement apr√®s avoir demand√© √† vos 4 meilleurs amis!




---
# Bonnes pratiques

### Organisation du travail

Un dossier pour chaque projet de recherche et diff√©rents sous-dossiers pour:

- Scripts      
  - un scripts par t√¢che: cleaning, statistiques descriptives, anlayse empirique
  
- Data     
  - `.rds`
  
- Figures
  
- (Admin)
  - par exemple les documents relatifs √† l'acc√®s √† une base de donn√©es
  


---
# Commenter son code pour soi...&lt;sup&gt;1&lt;/sup&gt;

&lt;img src="imgs/meme_comment_code.jpeg" width="50%" style="display: block; margin: auto;" /&gt;

---
# ... et ses coll√®gues&lt;sup&gt;1&lt;/sup&gt;

&lt;img src="imgs/headache.png" width="50%" style="display: block; margin: auto;" /&gt;


---
# **Essayer** de ne pas s'√©nerver&lt;sup&gt;1&lt;/sup&gt;

.pull-left[
&lt;img src="imgs/parenthesis.jpeg" width="70%" style="display: block; margin: auto;" /&gt;
]
.pull-right[
L'apprentissage de `R` est long et fastidieux, mais les rendements sont croissants!
.footnote[
[1]: R Memes For Statistical Fiends
]
]


---
# References

[Introduction √† l‚Äôanalyse d‚Äôenqu√™tes avec R et RStudio](https://larmarange.github.io/analyse-R/)      
[Introduction to Econometrics &amp; R Programming, Louis Sirugue](https://louissirugue.github.io/metrics_on_R/home.html)         
[Econometrics, Florian Oswald](https://github.com/ScPoEcon/ScPoEconometrics-Slides)         
[Causal inference: The Mixtape, Scott Cunningham](https://mixtape.scunning.com/01-introduction)      
[G√©omatique sur R](https://rcarto.github.io/geomatique_avec_r/)      

---
layout: false
class: center, middle, inverse

# Appendix

---
# Cheatsheets

- [R Studio Environment](https://rstudio.github.io/cheatsheets/rstudio-ide.pdf)
- [All cheatsheets](https://posit.co/resources/cheatsheets/)

---
name: cheatR

.center[
&lt;img src="imgs/cheatsheetR.png" width="70%" style="display: block; margin: auto;" /&gt;
]

[Back](#bestfriend)




    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
